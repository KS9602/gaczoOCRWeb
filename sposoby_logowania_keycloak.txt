1ï¸âƒ£ Authorization Code Flow (redirect na Keycloak)

â€Klasyczne logowanie uÅ¼ytkownikaâ€

Jak dziaÅ‚a (high-level):
Front (SPA / web) redirectuje usera na stronÄ™ Keycloak
User wpisuje login + hasÅ‚o w Keycloak
Keycloak redirectuje z powrotem do frontu z authorization_code
Front (lub backend) wymienia code â†’ access token + id token

Cechy:
âœ”ï¸ Najbezpieczniejszy flow dla uÅ¼ytkownikÃ³w
âœ”ï¸ HasÅ‚o nigdy nie trafia do aplikacji
âœ”ï¸ PeÅ‚ne wsparcie MFA, SSO, social loginÃ³w
âŒ Wymaga redirectÃ³w (nie do CLI / batch)

Kiedy uÅ¼ywaÄ‡:
Aplikacje webowe
SPA (React, Angular, Vue)
Mobile




2ï¸âƒ£ Authorization Code + PKCE

To jest TEN SAM flow co wyÅ¼ej, tylko utwardzony

Co dodaje PKCE?:
code_verifier â€“ losowy sekret w kliencie
code_challenge â€“ hash code_verifier

Keycloak wydaje token tylko jeÅ›li klient zna verifier

Dlaczego to waÅ¼ne

Chroni przed:
przechwyceniem authorization_code
atakiem MITM
ZastÄ™puje client_secret

Cechy
âœ”ï¸ OBOWIÄ„ZKOWY dla SPA
âœ”ï¸ Bezpieczny nawet bez secretu
âŒ TrochÄ™ bardziej skomplikowany

Kiedy uÅ¼ywaÄ‡
SPA
Mobile
Public clients (bez secretu)

ğŸ“Œ Dzisiaj:
Authorization Code + PKCE to standard nr 1

3ï¸âƒ£ Authorization Code (Backend-for-Frontend)

Front tylko redirectuje, backend robi tokeny

Jak dziaÅ‚a
Front redirectuje usera na Keycloak
Keycloak wraca z code â†’ do backendu
Backend wymienia code na tokeny
Backend trzyma tokeny (session / cookie)

Cechy

âœ”ï¸ Tokeny nigdy nie trafiajÄ… do JS
âœ”ï¸ Bardzo bezpieczne
âŒ WiÄ™cej infrastruktury

Kiedy uÅ¼ywaÄ‡:
Web klasy enterprise
Wysokie wymagania bezpieczeÅ„stwa
Aplikacje bankowe

4ï¸âƒ£ Client Credentials Flow

Backend â†” Backend (bez uÅ¼ytkownika)

Jak dziaÅ‚a
Mikroserwis wysyÅ‚a:
client_id + client_secret


Dostaje access_token
Token reprezentuje aplikacjÄ™, nie usera

Cechy
âœ”ï¸ Proste
âœ”ï¸ Idealne do serwisÃ³w technicznych
âŒ Brak uÅ¼ytkownika (sub = clientId)

Kiedy uÅ¼ywaÄ‡
Mikroserwis â†’ mikroserwis
CRON, batch, worker
Integracje systemowe

ğŸ“Œ Bardzo czÄ™sto uÅ¼ywane w Springu